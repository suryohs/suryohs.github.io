<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Aplikasi Tes — Load Langsung dari Google Sheets CSV</title>
<style>
  :root{
    --bg:#0b1220; --card:#071029; --accent:#06b6d4; --muted:#94a3b8;
    --ok:#10b981; --err:#ef4444; --glass: rgba(255,255,255,0.03);
  }
  *{box-sizing:border-box}
  body{
    margin:0; min-height:100vh; font-family:Inter,system-ui,Arial;
    display:flex; align-items:center; justify-content:center;
    background:linear-gradient(180deg,#071029 0%, #021025 100%); color:#e6eef8;
    padding:20px;
  }
  .wrap{width:100%; max-width:980px}
  .card{
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:12px; padding:18px; border:1px solid rgba(255,255,255,0.03);
    box-shadow: 0 10px 30px rgba(1,6,23,0.6);
  }
  header{display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:12px}
  h1{font-size:1.05rem; margin:0}
  .meta{color:var(--muted); font-size:0.9rem}
  .progress{height:10px; background:rgba(255,255,255,0.03); border-radius:999px; overflow:hidden; margin:12px 0}
  .progress > i{display:block; height:100%; background:linear-gradient(90deg,var(--accent),#3b82f6); width:0%; transition:width .35s}
  .question-card{padding:14px; border-radius:10px; border:1px solid rgba(255,255,255,0.02); background:var(--glass)}
  .qtext{white-space:pre-wrap; margin-bottom:12px; line-height:1.45}
  .options{display:grid; gap:8px}
  .opt{
    padding:10px 12px; border-radius:8px; background:transparent; border:1px solid rgba(255,255,255,0.03);
    cursor:pointer; transition:transform .08s, box-shadow .12s; color:#dbeafe;
  }
  .opt:hover{transform:translateY(-3px)}
  .opt.disabled{opacity:0.7; cursor:default; transform:none}
  .opt.correct{background:rgba(16,185,129,0.08); border-color:rgba(16,185,129,0.35); color:#bbf7d0}
  .opt.wrong{background:rgba(239,68,68,0.06); border-color:rgba(239,68,68,0.35); color:#fecaca}
  .controls{display:flex; gap:8px; align-items:center; margin-top:12px}
  .btn{padding:10px 14px; border-radius:9px; border:none; cursor:pointer; font-weight:600}
  .btn.primary{background:linear-gradient(180deg,var(--accent),#2563eb); color:white}
  .btn.ghost{background:transparent; border:1px solid rgba(255,255,255,0.04); color:var(--muted)}
  .feedback{margin-top:10px; font-size:0.95rem}
  .explanation{margin-top:12px; padding:12px; border-radius:8px; background:rgba(255,255,255,0.02); color:#cfe9ff; border:1px dashed rgba(255,255,255,0.03); white-space:pre-wrap}
  .small{font-size:0.9rem; color:var(--muted)}
  footer{margin-top:14px; text-align:right; color:var(--muted); font-size:0.85rem}
  @media(min-width:720px){ .options{grid-template-columns:1fr 1fr} }
</style>
</head>
<body>
<div class="wrap">
  <div class="card" id="app">
    <header>
      <div>
        <h1>Aplikasi Tes — Ambil Soal dari Google Sheets (CSV)</h1>
        <div class="meta">Soal dimuat langsung dari spreadsheet publik (CSV). Soal & opsi diacak.</div>
      </div>
      <div style="text-align:right">
        <div class="meta">URL CSV yang dipakai:</div>
        <div id="csvUrl" class="small" style="max-width:360px; overflow-wrap:anywhere"></div>
        <div id="qcount" class="meta">Memuat...</div>
      </div>
    </header>

    <div class="progress" aria-hidden><i id="pct"></i></div>

    <div id="content">
      <div style="margin-bottom:8px">
        <label class="small">Masukkan (atau ganti) URL CSV publik:</label>
        <input id="urlInput" style="width:100%; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:#e6eef8" />
      </div>

      <div id="loader" class="small">Klik "Muat Soal" untuk ambil soal dari spreadsheet publik.</div>

      <div id="questionArea" style="display:none">
        <div class="question-card">
          <div class="qtext" id="qtext">...</div>
          <div class="options" id="options"></div>
          <div class="feedback" id="feedback"></div>
          <div class="explanation" id="explanation" style="display:none"></div>
          <div class="controls">
            <button class="btn primary" id="nextBtn" style="display:none">Soal Berikutnya</button>
            <button class="btn ghost" id="restartBtn">Ulang Tes</button>
            <div style="flex:1"></div>
            <div class="small" id="scoreBox"></div>
          </div>
        </div>
      </div>

    </div>

    <footer>Catatan: spreadsheet harus dipublish & dapat diakses publik. Jika browser menolak fetch karena CORS, coba buka lewat server lokal atau host file di web.</footer>
  </div>
</div>

<script>
/* CONFIG: default URL (user-provided CSV public link) */
const defaultCSV = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSSlOM7ASWaqcIjgmPcqrN5TjMWZVYACgeIYek-DxeQ3Jg5odZs_07XVWnvSxr0KWE3EbI-dJvvC8j8/pub?gid=0&single=true&output=csv";

const urlInput = document.getElementById('urlInput');
const csvUrlDisplay = document.getElementById('csvUrl');
const loader = document.getElementById('loader');
const qcount = document.getElementById('qcount');
const pct = document.getElementById('pct');

const questionArea = document.getElementById('questionArea');
const qtext = document.getElementById('qtext');
const optionsDiv = document.getElementById('options');
const feedback = document.getElementById('feedback');
const explanation = document.getElementById('explanation');
const nextBtn = document.getElementById('nextBtn');
const restartBtn = document.getElementById('restartBtn');
const scoreBox = document.getElementById('scoreBox');

let questions = []; // array of {question, options:[], correctIndex, explanation}
let order = [];
let current = 0;
let score = 0;

/* --- Utilities --- */
function shuffle(a){
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

/* Robust CSV parser (handles quoted cells) */
function parseCSV(text){
  const rows = [];
  let cur = '';
  let row = [];
  let inQuotes = false;

  for(let i=0;i<text.length;i++){
    const ch = text[i];
    const nxt = text[i+1];

    if(ch === '"' ){
      if(inQuotes && nxt === '"'){ // escaped quote
        cur += '"'; i++; // skip next
      } else {
        inQuotes = !inQuotes;
      }
    } else if(ch === ',' && !inQuotes){
      row.push(cur);
      cur = '';
    } else if((ch === '\n' || ch === '\r') && !inQuotes){
      // handle CRLF (\r\n)
      if(ch === '\r' && nxt === '\n'){ /* skip, will process at \n */ }
      row.push(cur);
      // skip empty trailing row sometimes
      const allEmpty = row.every(c => c === '');
      if(!(row.length === 1 && row[0] === '')) rows.push(row.slice());
      row = [];
      cur = '';
      // if CRLF, next loop will see \n and skip adding empty row, ok
    } else {
      cur += ch;
    }
  }
  // push remainder
  if(inQuotes){
    // malformed but push what we have
    row.push(cur);
    rows.push(row);
  } else {
    if(cur !== '' || row.length>0){
      row.push(cur);
      rows.push(row);
    }
  }
  return rows;
}

/* detect header names */
function detectHeaders(headers){
  // normalize headers to lowercase trimmed
  const norm = headers.map(h=> (h||'').toString().trim().toLowerCase());
  const map = {};
  // question header candidates
  const questionCandidates = ['question','soal','pertanyaan','tanya'];
  const optionCandidates = ['a','b','c','d','option a','option b','option c','option d','pilihan a','pilihan b','pilihan c','pilihan d','opsi a','opsi b','opsi c','opsi d'];
  const allOptionsCombined = ['options','pilihan','choices','opsi'];
  const answerCandidates = ['answer','kunci','kunci jawaban','jawaban','key'];
  const explanationCandidates = ['pembahasan','explanation','solution','penjelasan'];

  // find question
  for(let i=0;i<norm.length;i++){
    if(questionCandidates.includes(norm[i]) || /soal/i.test(headers[i])){
      map.question = headers[i];
      map.questionIx = i;
      break;
    }
  }
  // find options A-D
  const optionCols = [];
  for(let i=0;i<norm.length;i++){
    const h = norm[i];
    if(['a','b','c','d'].includes(h) || /^option\s*[abcd]$/.test(h) || /^pilihan\s*[abcd]$/.test(h) || /^opsi\s*[abcd]$/.test(h)){
      optionCols.push({name:headers[i], ix:i});
    }
  }
  // find combined options column
  let combinedOptionsCol = -1;
  for(let i=0;i<norm.length;i++){
    if(allOptionsCombined.includes(norm[i]) || /pilihan/i.test(headers[i]) && !/jawaban/i.test(headers[i])){
      combinedOptionsCol = i; break;
    }
  }

  // find answer column
  let answerCol = -1;
  for(let i=0;i<norm.length;i++){
    if(answerCandidates.includes(norm[i]) || /kunci/i.test(headers[i]) || /jawaban/i.test(headers[i])){
      answerCol = i; break;
    }
  }

  // find explanation column
  let explCol = -1;
  for(let i=0;i<norm.length;i++){
    if(explanationCandidates.includes(norm[i]) || /pembahasan/i.test(headers[i]) || /penjelasan/i.test(headers[i])){
      explCol = i; break;
    }
  }

  map.optionCols = optionCols; // array of {name,ix}
  map.combinedOptionsCol = combinedOptionsCol; // index or -1
  map.answerCol = answerCol;
  map.explCol = explCol;

  // fallback heuristics if none found:
  if(!map.question && norm.length>0){
    // assume first column
    map.question = headers[0];
    map.questionIx = 0;
  }
  return map;
}

/* Build internal questions array from CSV rows and header map */
function buildQuestions(rows){
  const headers = rows[0] || [];
  const map = detectHeaders(headers);
  const res = [];
  for(let r=1;r<rows.length;r++){
    const row = rows[r];
    if(row.length === 0) continue;
    const qtext = (row[map.questionIx] || '').toString().trim();
    if(!qtext) continue;

    let opts = [];
    // if explicit A-D columns present
    if(map.optionCols && map.optionCols.length >= 4){
      // ensure order A,B,C,D
      const sorted = map.optionCols.slice().sort((x,y)=> x.ix - y.ix);
      for(const oc of sorted) opts.push((row[oc.ix]||'').toString().trim());
    } else if(map.combinedOptionsCol >= 0 && row[map.combinedOptionsCol]){
      // combined options in one cell - try to split by line breaks or ; or |
      const raw = row[map.combinedOptionsCol].toString();
      let parts = raw.split(/\r\n|\n|\r/).map(s=>s.trim()).filter(s=>s);
      if(parts.length < 2) parts = raw.split(/[|;]/).map(s=>s.trim()).filter(s=>s);
      // Sometimes combined has "A. text; B. text"
      if(parts.length===1){
        const splitted = raw.split(/(?=[A-D]\s*\.|[A-D]\s*[:\)]|[A-D]\s*-)/i);
        if(splitted.length>1){
          parts = splitted.map(s=> s.replace(/^[A-D]\s*[\.\:\)\-]?\s*/i,'').trim()).filter(Boolean);
        }
      }
      opts = parts;
    } else {
      // try columns named "pilihan a" etc by matching header names (case-insensitive)
      const maybeOpts = [];
      for(let i=0;i<headers.length;i++){
        const h = headers[i].toString().toLowerCase();
        if(/\b(a|b|c|d)\b/.test(h) || /pilihan|opsi|option/.test(h)) {
          maybeOpts.push({ix:i, header:h});
        }
      }
      if(maybeOpts.length>=4){
        maybeOpts.sort((x,y)=>x.ix - y.ix);
        opts = maybeOpts.map(m=> (row[m.ix]||'').toString().trim());
      }
    }

    // if options less than 2, attempt to parse in-row lookups (skip this row)
    if(opts.length < 2){
      // fallback: if there are many columns, take next 4 columns after question column
      const start = (map.questionIx || 0) + 1;
      for(let k=start; k<Math.min(row.length, start+4); k++){
        if((row[k]||'').toString().trim()) opts.push(row[k].toString().trim());
      }
    }

    // answer (raw)
    let rawAnswer = '';
    if(map.answerCol >=0) rawAnswer = (row[map.answerCol]||'').toString().trim();
    // try also header named 'kunci' etc in other columns if answer empty
    if(!rawAnswer){
      // search any cell that equals A/B/C/D or that matches one option exactly
      for(let i=0;i<row.length;i++){
        const v = (row[i]||'').toString().trim();
        if(['a','b','c','d','A','B','C','D'].includes(v)){ rawAnswer = v; break; }
      }
    }

    const expl = (map.explCol >= 0 && row[map.explCol]) ? row[map.explCol].toString().trim() : '';

    // normalize: determine correctIndex
    let correctIndex = -1;
    if(rawAnswer){
      const ra = rawAnswer.trim();
      // if ra is single letter A-D
      if(/^[A-D]$/i.test(ra) && opts.length >= 4){
        const letter = ra.toUpperCase();
        const idx = {'A':0,'B':1,'C':2,'D':3}[letter];
        if(typeof idx === 'number') correctIndex = idx;
      } else {
        // try to match answer text to one of options (strict match)
        for(let i=0;i<opts.length;i++){
          if(opts[i] && opts[i].toString().trim() === ra) { correctIndex = i; break; }
        }
        // try case-insensitive contains
        if(correctIndex === -1){
          for(let i=0;i<opts.length;i++){
            if(opts[i] && opts[i].toString().toLowerCase().includes(ra.toLowerCase()) && ra.length>0){
              correctIndex = i; break;
            }
          }
        }
      }
    }

    // final fallback: if no correctIndex but options exist and rawAnswer is empty, assume opts[0] correct (best-effort)
    if(correctIndex === -1 && opts.length>0){
      // try matching numeric equality if answer is numeric inside some other column
      if(rawAnswer && !isNaN(parseFloat(rawAnswer))){
        for(let i=0;i<opts.length;i++){
          const nopt = parseFloat((opts[i]||'').toString().replace(/[^\d\.\-]/g,''));
          if(!isNaN(nopt) && nopt === parseFloat(rawAnswer)){ correctIndex = i; break; }
        }
      }
    }

    res.push({
      question: qtext,
      rawOptions: opts.slice(), // copy
      correctIndex,
      rawAnswer,
      explanation: expl
    });
  }
  return res;
}

/* Convert built questions into runtime format: produce options array and set correctIndex if possible */
function prepareRuntimeQuestions(built){
  const out = [];
  for(const b of built){
    // ensure options array length >=2
    let opts = b.rawOptions.filter(Boolean).map(s=>s.toString().trim());
    if(opts.length < 2){
      // if options missing, create placeholder options (generate 3 distractors)
      const correctText = b.rawAnswer || "Jawaban";
      opts = [correctText];
      while(opts.length < 4){
        const cand = correctText + " " + (Math.floor(Math.random()*90)+10);
        if(!opts.includes(cand)) opts.push(cand);
      }
    } else if(opts.length === 2){
      // expand to 4 by adding slight variants
      while(opts.length < 4) opts.push(opts[opts.length-1] + " (alt" + (opts.length+1) + ")");
    } else if(opts.length === 3){
      // add one dummy
      opts.push(opts[0] + " (alt)");
    }

    // determine correct index robustly
    let correctIndex = b.correctIndex;
    if(correctIndex === -1){
      // try match rawAnswer (if letter) again
      const ra = b.rawAnswer || '';
      if(/^[A-D]$/i.test(ra)){
        const idx = {'A':0,'B':1,'C':2,'D':3}[ra.toUpperCase()];
        correctIndex = idx;
      } else if(ra){
        for(let i=0;i<opts.length;i++){
          if(opts[i].toString().trim() === ra.toString().trim()) { correctIndex = i; break; }
        }
      }
    }

    // last fallback: treat first option as correct if none detected
    if(correctIndex === -1) correctIndex = 0;

    out.push({
      question: b.question,
      options: opts.slice(),
      correctIndex: correctIndex,
      explanation: b.explanation || ''
    });
  }
  return out;
}

/* Render a question on screen */
function renderQuestion(idx){
  const q = questions[idx];
  qtext.innerText = `Soal ${idx+1}:\n\n${q.question}`;
  optionsDivClear();
  feedback.innerText = '';
  explanation.style.display = 'none';
  nextBtn.style.display = 'none';

  // create option elements with random order
  const optIndices = q.options.map((_,i)=>i);
  shuffle(optIndices);
  // remember mapping from element -> original index
  optIndices.forEach(pos=>{
    const d = document.createElement('div');
    d.className = 'opt';
    d.tabIndex = 0;
    d.innerText = q.options[pos];
    d.dataset.optIndex = pos;
    d.onclick = ()=>selectOption(d, pos);
    d.onkeydown = (e)=>{ if(e.key === 'Enter' || e.key === ' ') selectOption(d,pos); };
    optionsDiv.appendChild(d);
  });

  // update progress & counters
  const pctVal = Math.round((idx / questions.length) * 100);
  pct.style.width = pctVal + '%';
  qcount.innerText = `${idx+1} / ${questions.length} soal`;
  scoreBox.innerText = `Skor: ${score} / ${questions.length}`;
}

/* clear options area */
function optionsDivClear(){
  optionsDiv.innerHTML = '';
}

/* handle selection */
function selectOption(elem, chosenIndex){
  const q = questions[current];
  // disable all options
  const all = document.querySelectorAll('.opt');
  all.forEach(o=>{ o.classList.add('disabled'); o.onclick = null; });

  const correctIndex = q.correctIndex;
  // find the DOM element that holds correct answer (by data-optindex)
  all.forEach(o=>{
    if(parseInt(o.dataset.optIndex) === correctIndex){
      o.classList.add('correct');
    }
  });

  if(chosenIndex === correctIndex){
    elem.classList.add('correct');
    feedback.innerHTML = `<strong style="color: #bbf7d0">Benar.</strong>`;
    score++;
  } else {
    elem.classList.add('wrong');
    // show which is correct in feedback (letter + text)
    // find letter mapping
    const correctText = q.options[correctIndex];
    let letter = '?';
    // determine current order of displayed options to find letter A-D
    const displayed = Array.from(document.querySelectorAll('.opt'));
    let cIdx = displayed.findIndex(d=> parseInt(d.dataset.optIndex) === correctIndex);
    if(cIdx >= 0) letter = String.fromCharCode(65 + cIdx);
    feedback.innerHTML = `<strong style="color: #fecaca">Salah.</strong> Jawaban benar: <strong>${correctText}</strong>`;
  }

  // show pembahasan if available
  if(q.explanation && q.explanation.trim()){
    explanation.style.display = 'block';
    explanation.innerText = `Pembahasan:\n\n${q.explanation}`;
  }

  scoreBox.innerText = `Skor: ${score} / ${questions.length}`;
  nextBtn.style.display = 'inline-block';
}

/* next button */
nextBtn.onclick = ()=>{
  current++;
  if(current >= questions.length){
    // finished
    qtext.innerText = "Tes selesai.";
    optionsDivClear();
    feedback.innerHTML = `<strong>Hasil akhir: ${score} / ${questions.length}</strong>`;
    explanation.style.display = 'block';
    explanation.innerText = `Tes selesai. Skor Anda: ${score} dari ${questions.length}. Klik "Ulang Tes" untuk mengacak dan coba lagi.`;
    pct.style.width = '100%';
    qcount.innerText = `Selesai • ${questions.length}/${questions.length}`;
    nextBtn.style.display = 'none';
  } else {
    renderQuestion(current);
  }
};

/* restart (re-load with same dataset and reshuffle) */
restartBtn.onclick = ()=>{
  if(!questions.length) return;
  shuffle(questions);
  current = 0; score = 0;
  renderQuestion(0);
  nextBtn.style.display = 'none';
  explanation.style.display = 'none';
  feedback.innerText = '';
};

/* fetch CSV from URL and initialize */
async function loadCSV(url){
  try{
    loader.innerText = 'Memuat CSV...';
    csvUrlDisplay.innerText = url;
    const res = await fetch(url);
    if(!res.ok) throw new Error(`Fetch gagal: ${res.status}`);
    const txt = await res.text();
    // parse
    const rows = parseCSV(txt);
    if(rows.length < 2) throw new Error('CSV terdeteksi kosong atau hanya header.');
    const built = buildQuestions(rows);
    const runtime = prepareRuntimeQuestions(built);
    if(runtime.length === 0) throw new Error('Tidak ada soal valid di CSV.');
    questions = runtime;
    shuffle(questions);
    current = 0; score = 0;
    // show UI
    document.getElementById('loader').style.display = 'none';
    questionArea.style.display = 'block';
    renderQuestion(0);
    loader.style.display = 'none';
    qcount.innerText = `Memuat ${questions.length} soal • Siap`;
  }catch(err){
    loader.innerText = `Gagal memuat CSV: ${err.message}`;
    console.error(err);
  }
}

/* init */
(function init(){
  urlInput.value = defaultCSV;
  csvUrlDisplay.innerText = defaultCSV;
  // auto-load default CSV
  loadCSV(defaultCSV);
  // allow manual load when pressing Enter on input
  urlInput.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter'){
      const url = urlInput.value.trim();
      if(url) {
        // reset UI
        document.getElementById('loader').style.display = 'block';
        document.getElementById('loader').innerText = 'Memuat soal...';
        questionArea.style.display = 'none';
        loadCSV(url);
      }
    }
  });
})();
</script>
</body>
</html>
